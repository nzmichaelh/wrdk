;; GCC machine description for EPSON C33
;; Copyright (C) 1996, 1997 Free Software Foundation, Inc.

;;   Contributed by Jeff Law (law@cygnus.com).

;; This file is part of GNU CC.

;; GNU CC is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; GNU CC is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU CC; see the file COPYING.  If not, write to
;; the Free Software Foundation, 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.


;; See file "rtl.def" for documentation on define_insn, match_*, et. al.


;; Types of instructions (for scheduling purposes). C33: Add instrucutions for branch.

(define_attr "type" "load,branch,other"
  (const_string "other"))

;; The size of instructions in bytes.

(define_attr "length" "" 
  (cond [(eq_attr "type" "branch")
	 (if_then_else (and (ge (minus (pc) (match_dup 0))
				(const_int -254))
			    (le (minus (pc) (match_dup 0))
;				(const_int 256)))
				(const_int 258)))
		       (const_int 2)
		       (if_then_else (and (ge (minus (pc) (match_dup 0))
					      (const_int -2097150))
					  (le (minus (pc) (match_dup 0))
					      (const_int 2097152)))
				     (const_int 4)
				     (const_int 6)))]
	(const_int 200)))

(define_function_unit "memory" 1 1 (eq_attr "type" "load") 2 0)

; Definitions for filling branch delay slots.

(define_attr "needs_delay_slot" "yes,no" (const_string "no"))

(define_attr "in_delay_slot" "yes,no" (const_string "no"))

(define_delay
  (eq_attr "needs_delay_slot" "yes")
  [(eq_attr "in_delay_slot" "yes") (nil) (nil)])

;; ----------------------------------------------------------------------
;; MOVE INSTRUCTIONS
;; ----------------------------------------------------------------------

;; movqi

(define_expand "movqi"
  [(set (match_operand:QI 0 "general_operand_post_inc" "")
	(match_operand:QI 1 "general_operand_post_inc" ""))]
  ""
  "
{
  /* One of the ops has to be in a register */
  if (!register_operand (operand0, QImode)
      && !register_operand (operand1, QImode))
    operands[1] = copy_to_mode_reg (QImode, operand1);
}")

(define_insn "*movqi_internal"
  [(set (match_operand:QI 0 "general_operand_post_inc" "=r,r,r,r,m,r,>")
	(match_operand:QI 1 "general_operand_post_inc"      "r,K,n,m,r,>,r"))]
  "register_operand (operands[0], QImode)
   || register_operand (operands[1], QImode)"
  "* return output_move_single (operands, TRUE);"
  [(set_attr "length" "2,2,4,6,6,2,2")
   (set_attr "type" "other,other,other,load,other,load,other")
   (set_attr "in_delay_slot" "yes,yes,no,no,no,no,no")])

;; movhi

(define_expand "movhi"
  [(set (match_operand:HI 0 "general_operand_post_inc" "")
	(match_operand:HI 1 "general_operand_post_inc" ""))]
  ""
  "
{
  /* One of the ops has to be in a register */
  if (!register_operand (operand0, HImode)
      && !register_operand (operand1, HImode))
    operands[1] = copy_to_mode_reg (HImode, operand1);
}")

(define_insn "*movhi_internal"
  [(set (match_operand:HI 0 "general_operand_post_inc" "=r,r,r,r,m,r,>")
	(match_operand:HI 1 "general_operand_post_inc"      "r,K,n,m,r,>,r"))]
  "register_operand (operands[0], HImode)
   || register_operand (operands[1], HImode)"
  "* return output_move_single (operands, TRUE);"
  [(set_attr "length" "2,2,4,6,6,2,2")
   (set_attr "type" "other,other,other,load,other,load,other")
   (set_attr "in_delay_slot" "yes,yes,no,no,no,no,no")])


;; movsi and helpers

(define_expand "movsi"
  [(set (match_operand:SI 0 "general_operand_post_inc" "")
	(match_operand:SI 1 "general_operand_post_inc" ""))]
  ""
  "
{
  /* One of the ops has to be in a register */
  if (!register_operand (operand0, SImode)
      && !register_operand (operand1, SImode))
    operands[1] = copy_to_mode_reg (SImode, operand1);
}")

(define_insn "*movsi_internal"
  [(set (match_operand:SI 0 "general_operand_post_inc" "=r,r,f,r,r,r,r,m,r,>")
	(match_operand:SI 1 "general_operand_post_inc"     "r,f,r,K,L,m,i,r,>,r"))]
  "register_operand (operands[0], SImode)
   || register_operand (operands[1], SImode)"
  "* return output_move_single (operands, FALSE);"
  [(set_attr "length" "2,2,2,2,4,6,6,6,2,2")
   (set_attr "type" "other,other,other,other,other,load,other,other,load,other")
   (set_attr "in_delay_slot" "yes,no,no,yes,no,no,no,no,no,no")])

(define_expand "movdi"
  [(set (match_operand:DI 0 "general_operand" "")
	(match_operand:DI 1 "general_operand" ""))]
  ""
  "
{
  /* One of the ops has to be in a register */
  if (!register_operand (operand0, DImode)
      && !register_operand (operand1, DImode))
    operands[1] = copy_to_mode_reg (DImode, operand1);
}")

;;; CHG K.Watanabe V1.7 >>>>>>> 

;;;; (define_insn "*movdi_internal"
;;;;   [(set (match_operand:DI 0 "general_operand" "=r,r,r,r,r,m,r")
;;;; 	(match_operand:DI 1 "general_operand"  "r,K,L,i,m,r,iF"))]
;;;;   "register_operand (operands[0], DImode)
;;;;    || register_operand (operands[1], DImode)"
;;;;   "* return output_move_double (operands);"
;;;;   [(set_attr "length" "4,4,6,12,12,12,12")
;;;;    (set_attr "type" "other,other,other,other,load,other,other")])

(define_insn "*movdi_internal"
[(set (match_operand:DI 0 "general_operand" "=r,r,r,r,r,m,r")
(match_operand:DI 1 "general_operand"  "r,K,L,i,m,r,iF"))]
"register_operand (operands[0], DImode)
|| register_operand (operands[1], DImode)"
"* return output_move_double (operands);"
[(set_attr "length" "4,4,8,12,12,12,12")
(set_attr "type" "other,other,other,other,load,other,other")])
   
;;; CHG K.Watanabe V1.7 <<<<<<<
 
(define_expand "movsf"
  [(set (match_operand:SF 0 "general_operand" "")
	(match_operand:SF 1 "general_operand" ""))]
  ""
  "
{
  /* One of the ops has to be in a register or 0 */
  if (!register_operand (operand0, SFmode)
      && !register_operand (operand1, SFmode))
    operands[1] = copy_to_mode_reg (SFmode, operand1);
}")

(define_insn "*movsf_internal"
  [(set (match_operand:SF 0 "general_operand" "=r,r,m,r")
	(match_operand:SF 1 "general_operand"  "r,m,r,iF"))]
  "register_operand (operands[0], SFmode)
   || register_operand (operands[1], SFmode)"
  "* return output_move_single (operands, FALSE);"
  [(set_attr "length" "2,6,6,6")
   (set_attr "type" "other,load,other,other")
   (set_attr "in_delay_slot" "yes,no,no,no")])


(define_expand "movdf"
  [(set (match_operand:DF 0 "general_operand" "")
	(match_operand:DF 1 "general_operand" ""))]
  ""
  "
{
  /* One of the ops has to be in a register or 0 */
  if (!register_operand (operand0, DFmode)
      && !register_operand (operand1, DFmode))
    operands[1] = copy_to_mode_reg (DFmode, operand1);
}")

(define_insn "*movdf_internal"
  [(set (match_operand:DF 0 "general_operand" "=r,r,m,r")
	(match_operand:DF 1 "general_operand"  "r,m,r,iF"))]
  "register_operand (operands[0], DFmode)
   || register_operand (operands[1], DFmode)"
  "*
{
  rtx xoperands[10];

  xoperands[0] = operands[0];
  xoperands[1] = operands[1];
  
  output_asm_insn (output_move_double (xoperands), xoperands);
  return \"\";
}"
  [(set_attr "length" "4,12,12,12")
   (set_attr "type" "other,load,other,other")])

;; ----------------------------------------------------------------------
;; TEST INSTRUCTIONS
;; ----------------------------------------------------------------------

;;; CHG K.Watanabe V1.7 >>>>>>>
;;;; C33: The process of "tstsi" is sometimes omitted 
;;;;      in the case that "tstsi" is defined and compiled with "-O".
;;;;      In this case, the incorrect process is done in the case of
;;;;      "negative numbers - positive numbers => overflow".
;;;;      So disable "tstsi" in the case of "-O" or more.


;; C33: The comparison is the essential after the operation,
;;      if "tstsi" is defined.
;;
;;(define_insn "tstsi"
;;  [(set (cc0) (match_operand:SI 0 "register_operand" "r"))]
;;  ""
;;  "cmp\\t%0,0\\t;tstsi"
;;  [(set_attr "length" "2")
;;   (set_attr "in_delay_slot" "yes")])

(define_insn "tstsi"
  [(set (cc0) (match_operand:SI 0 "register_operand" "r"))]
  "optimize == 0"
  "cmp\\t%0,0\\t;tstsi"
  [(set_attr "length" "2")
   (set_attr "in_delay_slot" "yes")])

;;; CHG K.Watanabe V1.7 <<<<<<<


(define_insn "cmpsi"
  [(set (cc0)
    (compare (match_operand:SI 0 "register_operand" "r,r,r,r")
	     (match_operand:SI 1 "nonmemory_operand" "r,K,L,n")))]
  ""
  "@
  cmp\\t%0,%1
  xcmp\\t%0,%1\\t;%v1
  xcmp\\t%0,%1\\t;%v1
  xcmp\\t%0,%1\\t;%v1"
  [(set_attr "length" "2,2,4,6")
   (set_attr "in_delay_slot" "yes,yes,no,no")])



;; ----------------------------------------------------------------------
;; ADD INSTRUCTIONS
;; ----------------------------------------------------------------------

(define_insn "addsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r")
	(plus:SI (match_operand:SI 1 "register_operand" "0,0,0,0")
		 (match_operand:SI 2 "nonmemory_operand" "r,K,L,n")))]
  ""
  "*
{
  HOST_WIDE_INT value;
  switch (which_alternative) {
  case 0:	/* C33: In the case of matching the first restriction.( Add the register value. ) */
    return \"add\\t%0,%2\";
    break;
  case 1:	/* C33: In the case of matching the second restriction.( Add the immediate. ) */
  case 2:
  case 3:
    value = INTVAL(operands[2]);	/* C33: Take out the value of operand2. */
    if (value > 0) {				/* C33: In the case that operand2 is positive numbers. */
      return \"xadd\\t%0,%2\\t;%v2\";
    }
    else {							/* C33: In the case that operand2 is negative numbers. */
      return \"xsub\\t%0,%n2\\t;%v2\";
    }
    break;

  default:
    abort();
    return \"\";
  }
}"
  [(set_attr "length" "2,2,4,6")
   (set_attr "type" "other")
   (set_attr "in_delay_slot" "yes,yes,no,no")])



;; ----------------------------------------------------------------------
;; SUBTRACT INSTRUCTIONS
;; ----------------------------------------------------------------------

(define_insn "subsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r")
	(minus:SI (match_operand:SI 1 "register_operand" "0,0,0,0")
		  (match_operand:SI 2 "nonmemory_operand" "r,K,L,n")))]
  ""
  "*
{
  HOST_WIDE_INT value;
  switch (which_alternative) {
  case 0:	/* C33: In the case of matching the first restriction.( Subtract the register value. ) */
    return \"sub\\t%0,%2\";
    break;
  case 1:	/* C33: In the case of matching the second restriction.( Subtract the immediate. ) */
  case 2:
  case 3:
    value = INTVAL(operands[2]);	/* C33: Take out the value of operand2. */
    if (value > 0) {				/* C33: In the case that operand2 is positive numbers. */
      return \"xsub\\t%0,%2\\t;%v2\";
    }
    else {							/* C33: In the case that operand2 is negative numbers. */
      return \"xadd\\t%0,%n2\\t;%v2\";
    }
    break;

  default:
    abort();
    return \"\";
  }
}"
  [(set_attr "length" "2,2,4,6")
   (set_attr "type" "other")
   (set_attr "in_delay_slot" "yes,yes,no,no")])


(define_insn "negsi2"
  [(set (match_operand:SI 0 "register_operand" "=r")
        (neg:SI (match_operand:SI 1 "register_operand" "r")))]
  ""
  "not\\t%0,%1\\t;negsi2\\n\\tadd\\t%0,1"
;  "not %0,%1; add %0,1\\t#negsi2"
  [(set_attr "length" "4")])

;;; C33: If we have 0 register, we can do above with one struction,
;;;      but we don't have it, so do this with two instructions.
;;;      There is the other method that substract %1 after load 0.
             

;; ----------------------------------------------------------------------
;; MULTIPLY INSTRUCTIONS
;; ----------------------------------------------------------------------

;;; DEL K.Watanabe V1.8 >>>>>>> 
;;; compiler_known_isuues.txt -- No9
;;; C33: The definition of "mulqihi3/umulqihi3" which defines 8bit multiplication is not necessary 
;;;      because "mlt" instruction has only 16 bit multiplication and 32 bit multiplication.
;;;      Delete this definition because char type multiplication in negative numbers is incorrect
;;;      in the case that this definition is defined.
;;;(define_insn "mulqihi3"
;;;  [(set (match_operand:HI 0 "register_operand" "=r")
;;;	(mult:HI
;;;	  (sign_extend:HI (match_operand:QI 1 "register_operand" "r"))
;;;	  (sign_extend:HI (match_operand:QI 2 "register_operand" "r"))))]
;;;  ""
;;;  "mlt.h\\t%1,%2\\n\\tld.w\\t%0,%%alr\\t; mulqihi3"
;;;;  "mlt.h %1,%2; ld.w %0,alr\\t# mulqihi3"
;;;  [(set_attr "length" "4")
;;;   (set_attr "type" "other")])
;;;
;;;(define_insn "umulqihi3"
;;;  [(set (match_operand:HI 0 "register_operand" "=r")
;;;	(mult:HI
;;;	  (zero_extend:HI (match_operand:QI 1 "register_operand" "r"))
;;;	  (zero_extend:HI (match_operand:QI 2 "register_operand" "r"))))]
;;;  ""
;;;  "mltu.h\\t%1,%2\\n\\tld.w\\t%0,%%alr\\t; umulqihi3"
;;;;  "mltu.h %1,%2; ld.w %0,alr\\t# umulqihi3"
;;;  [(set_attr "length" "4")
;;;   (set_attr "type" "other")])
;; DEL K.Watanabe V1.8 <<<<<<<


(define_insn "mulhisi3"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(mult:SI
	  (sign_extend:SI (match_operand:HI 1 "register_operand" "r"))
	  (sign_extend:SI (match_operand:HI 2 "register_operand" "r"))))]
  ""
  "mlt.h\\t%1,%2\\n\\tld.w\\t%0,%%alr\\t; mulhisi3"
;  "mlt.h %1,%2; ld.w %0,alr\\t# mulhisi3"
  [(set_attr "length" "4")
   (set_attr "type" "other")])

(define_insn "umulhisi3"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(mult:SI
	  (zero_extend:SI (match_operand:HI 1 "register_operand" "r"))
	  (zero_extend:SI (match_operand:HI 2 "register_operand" "r"))))]
  ""
  "mltu.h\\t%1,%2\\n\\tld.w\\t%0,%%alr\\t; umulhisi3"
;  "mltu.h %1,%2; ld.w %0,alr\\t# umulhisi3"
  [(set_attr "length" "4")
   (set_attr "type" "other")])

(define_insn "mulsi3"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(mult:SI
	  (match_operand:SI 1 "register_operand" "r")
	  (match_operand:SI 2 "register_operand" "r")))]
  ""
  "mlt.w\\t%1,%2\\n\\tld.w\\t%0,%%alr\\t; mulsi3"
;  "mlt.w %1,%2; ld.w %0,alr\\t# mulsi3"
  [(set_attr "length" "4")
   (set_attr "type" "other")])


;; ----------------------------------------------------------------------
;; AND INSTRUCTIONS
;; ----------------------------------------------------------------------

(define_insn "andsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r")
	(and:SI (match_operand:SI 1 "register_operand" "0,0,0,0")
		(match_operand:SI 2 "nonmemory_operand" "r,K,L,n")))]
  ""
  "@
  and\\t%0,%2
  xand\\t%0,%2\\t;%v2
  xand\\t%0,%2\\t;%v2
  xand\\t%0,%2\\t;%v2"
  [(set_attr "length" "2,2,4,6")
   (set_attr "type" "other")
   (set_attr "in_delay_slot" "yes,yes,no,no")])


;; ----------------------------------------------------------------------
;; OR INSTRUCTIONS
;; ----------------------------------------------------------------------

(define_insn "iorsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r")
	(ior:SI (match_operand:SI 1 "register_operand" "0,0,0,0")
		(match_operand:SI 2 "nonmemory_operand" "r,K,L,n")))]
  ""
  "@
  or\\t%0,%2
  xoor\\t%0,%2\\t;%v2
  xoor\\t%0,%2\\t;%v2
  xoor\\t%0,%2\\t;%v2"
  [(set_attr "length" "2,2,4,6")
   (set_attr "type" "other")
   (set_attr "in_delay_slot" "yes,yes,no,no")])


;; ----------------------------------------------------------------------
;; XOR INSTRUCTIONS
;; ----------------------------------------------------------------------

(define_insn "xorsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r")
	(xor:SI (match_operand:SI 1 "register_operand" "0,0,0,0")
		(match_operand:SI 2 "nonmemory_operand" "r,K,L,n")))]
  ""
  "@
  xor\\t%0,%2
  xxor\\t%0,%2\\t;%v2
  xxor\\t%0,%2\\t;%v2
  xxor\\t%0,%2\\t;%v2"
  [(set_attr "length" "2,2,4,6")
   (set_attr "type" "other")
   (set_attr "in_delay_slot" "yes,yes,no,no")])


;; ----------------------------------------------------------------------
;; NOT INSTRUCTIONS
;; ----------------------------------------------------------------------

(define_insn "one_cmplsi2"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(not:SI (match_operand:SI 1 "register_operand" "r")))]
  ""
  "not %0,%1"
  [(set_attr "length" "2")
   (set_attr "in_delay_slot" "yes")])

   /* C33: Do not define logic negative of the immediate,
           because it is solved at the time of compiling.  */
   

;; -----------------------------------------------------------------
;; BIT FIELDS
;; -----------------------------------------------------------------

/* C33: Unnecessary in C33. */

;; -----------------------------------------------------------------
;; Scc INSTRUCTIONS
;; -----------------------------------------------------------------

/* C33: Do not define "Scc" in C33 because C33 do not have the instruction
        which sets the value accroding to the condition judgment.           */

;; -----------------------------------------------------------------
;; C33: BIT OPERATION INSTRUCTIONS
;; -----------------------------------------------------------------

(define_peephole
  [(set (match_operand:QI 0 "register_operand" "=r") 
		(match_operand:QI 1 "memory_operand" "m"))
   (set (match_operand:SI 2 "register_operand" "=r") 
        (and:SI (match_operand:SI 3 "register_operand" "r")
			    (match_operand:SI 4 "const_int_operand" "n")))
   (set (cc0) (match_operand:SI 5 "register_operand" "r"))]

  "/* C33: The registers must not be used in the future. */
   dead_or_set_p (insn, operands[0])
   && dead_or_set_p (insn, operands[2])
   /* C33: The registers for the process must be the same. */
   && (REGNO(operands[0]) == REGNO(operands[2]))
   && (REGNO(operands[0]) == REGNO(operands[5]))
   /* C33: Operation object must be 1bit. */
   && (GET_CODE(operands[4]) == CONST_INT)
   && ((INTVAL(operands[4]) == 0x01) || (INTVAL(operands[4]) == 0x02)
	|| (INTVAL(operands[4]) == 0x04) || (INTVAL(operands[4]) == 0x08)
	|| (INTVAL(operands[4]) == 0x10) || (INTVAL(operands[4]) == 0x20)
	|| (INTVAL(operands[4]) == 0x40) || (INTVAL(operands[4]) == 0x80)
	|| (INTVAL(operands[4]) == 0xffffff80))
   /* C33: The memory reference must not be %sp indirect. */
   && !((GET_CODE(XEXP(operands[1], 0)) == PLUS)
    && (REGNO(XEXP(XEXP(operands[1], 0), 0)) == STACK_POINTER_REGNUM))
   && !((GET_CODE(XEXP(operands[1], 0)) == REG)
    && (REGNO(XEXP(operands[1], 0)) == STACK_POINTER_REGNUM))
   /* C33: The reference destination must not be defaut data area in the case of Advanced mode. */
   && !(TARGET_C33ADV
    && (GET_CODE(XEXP(operands[1], 0)) == SYMBOL_REF)
    && (!ENCODED_NAME_P(XSTR(XEXP(operands[1], 0), 0))))
   && !(TARGET_C33ADV
    && (GET_CODE(XEXP(operands[1], 0)) == CONST)
    && (!ENCODED_NAME_P(XSTR(XEXP(XEXP(XEXP(operands[1], 0), 0), 0), 0))))"
  "* return output_btst (operands);")


(define_peephole
  [(set (match_operand:QI 0 "register_operand" "=r")
		(match_operand:QI 1 "memory_operand" "m"))
   (set (match_operand:SI 2 "register_operand" "=r") 
        (and:SI (match_operand:SI 3 "register_operand" "r")
			    (match_operand:SI 4 "const_int_operand" "n")))
   (set (match_dup 1) 
		(match_operand:QI 5 "register_operand" "r"))]

  "/* C33: The registers must not be used in the future. */
   dead_or_set_p (insn, operands[0])
   && dead_or_set_p (insn, operands[2])
   /* C33: The registers for the process must be the same. */
   && (REGNO(operands[0]) == REGNO(operands[2]))
   && (REGNO(operands[0]) == REGNO(operands[5]))
   /* C33: Operation object must be 1bit. */
   && (GET_CODE(operands[4]) == CONST_INT)
   && (((INTVAL(operands[4]) & 0xff) == 0xfe)
       || ((INTVAL(operands[4]) & 0xff) == 0xfd)
       || ((INTVAL(operands[4]) & 0xff) == 0xfb)
       || ((INTVAL(operands[4]) & 0xff) == 0xf7)
       || ((INTVAL(operands[4]) & 0xff) == 0xef)
       || ((INTVAL(operands[4]) & 0xff) == 0xdf)
       || ((INTVAL(operands[4]) & 0xff) == 0xbf)
       || ((INTVAL(operands[4]) & 0xff) == 0x7f))
   /* C33: The memory reference must not be %sp indirect. */
   && !((GET_CODE(XEXP(operands[1], 0)) == PLUS)
    && (REGNO(XEXP(XEXP(operands[1], 0), 0)) == STACK_POINTER_REGNUM))
   && !((GET_CODE(XEXP(operands[1], 0)) == REG)
    && (REGNO(XEXP(operands[1], 0)) == STACK_POINTER_REGNUM))
   /* C33: The reference destination must not be defaut data area in the case of Advanced mode. */
   && !(TARGET_C33ADV
    && (GET_CODE(XEXP(operands[1], 0)) == SYMBOL_REF)
    && (!ENCODED_NAME_P(XSTR(XEXP(operands[1], 0), 0))))
   && !(TARGET_C33ADV
    && (GET_CODE(XEXP(operands[1], 0)) == CONST)
    && (!ENCODED_NAME_P(XSTR(XEXP(XEXP(XEXP(operands[1], 0), 0), 0), 0))))"
  "* return output_bclr (operands);")


(define_peephole
  [(set (match_operand:QI 0 "register_operand" "=r")
		(match_operand:QI 1 "memory_operand" "m"))
   (set (match_operand:SI 2 "register_operand" "=r") 
        (ior:SI (match_operand:SI 3 "register_operand" "r")
		(match_operand:SI 4 "const_int_operand" "n")))
   (set (match_dup 1)
		(match_operand:QI 5 "register_operand" "r"))]

  "/* C33: The registers must not be used in the future. */
   dead_or_set_p (insn, operands[0])
   && dead_or_set_p (insn, operands[2])
   /* C33: The registers for the process must be the same. */
   && (REGNO(operands[0]) == REGNO(operands[2]))
   && (REGNO(operands[0]) == REGNO(operands[5]))
   /* C33: Operation object must be 1bit. */
   && (GET_CODE(operands[4]) == CONST_INT)
   && (((INTVAL(operands[4]) & 0xff) == 0x01)
       || ((INTVAL(operands[4]) & 0xff) == 0x02)
	   || ((INTVAL(operands[4]) & 0xff) == 0x04)
	   || ((INTVAL(operands[4]) & 0xff) == 0x08)
	   || ((INTVAL(operands[4]) & 0xff) == 0x10)
	   || ((INTVAL(operands[4]) & 0xff) == 0x20)
	   || ((INTVAL(operands[4]) & 0xff) == 0x40)
 	   || ((INTVAL(operands[4]) & 0xff) == 0x80))
   /* C33: The memory reference must not be %sp indirect. */
   && !((GET_CODE(XEXP(operands[1], 0)) == PLUS)
    && (REGNO(XEXP(XEXP(operands[1], 0), 0)) == STACK_POINTER_REGNUM))
   && !((GET_CODE(XEXP(operands[1], 0)) == REG)
    && (REGNO(XEXP(operands[1], 0)) == STACK_POINTER_REGNUM))
   /* C33: The reference destination must not be defaut data area in the case of Advanced mode. */
   && !(TARGET_C33ADV
    && (GET_CODE(XEXP(operands[1], 0)) == SYMBOL_REF)
    && (!ENCODED_NAME_P(XSTR(XEXP(operands[1], 0), 0))))
   && !(TARGET_C33ADV
    && (GET_CODE(XEXP(operands[1], 0)) == CONST)
    && (!ENCODED_NAME_P(XSTR(XEXP(XEXP(XEXP(operands[1], 0), 0), 0), 0))))"
  "* return output_bset (operands);")


;; ----------------------------------------------------------------------
;; JUMP INSTRUCTIONS
;; ----------------------------------------------------------------------

;; Conditional jump instructions

(define_expand "ble"
  [(set (pc)
	(if_then_else (le (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "bleu"
  [(set (pc)
	(if_then_else (leu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "bge"
  [(set (pc)
	(if_then_else (ge (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "bgeu"
  [(set (pc)
	(if_then_else (geu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "blt"
  [(set (pc)
	(if_then_else (lt (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "bltu"
  [(set (pc)
	(if_then_else (ltu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "bgt"
  [(set (pc)
	(if_then_else (gt (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "bgtu"
  [(set (pc)
	(if_then_else (gtu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "beq"
  [(set (pc)
	(if_then_else (eq (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "bne"
  [(set (pc)
	(if_then_else (ne (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

/* C33: The conditional branch is the same to V850 so far. */

(define_insn "*branch_normal"
  [(set (pc)
	(if_then_else (match_operator 1 "comparison_operator"
				      [(cc0) (const_int 0)])
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "*
{
  if (get_attr_length (insn) == 2)
    return \"jr%b1%#\\t%l0\";
  else if (get_attr_length (insn) == 4)
    /* return \"ext %l0@rm\; jr%b1%# %l0@rl\"; */
    return \"sjr%b1%#\\t%l0\";
  else
    /* return \"ext %l0@rh\; ext %l0@rm\; jr%b1%# %l0@rl\"; */
    return \"xjr%b1%#\\t%l0\";
}"
 [(set_attr "type" "branch")
  (set_attr "needs_delay_slot" "yes")])


(define_insn "*branch_invert"
  [(set (pc)
	(if_then_else (match_operator 1 "comparison_operator"
				      [(cc0) (const_int 0)])
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "*
{
  if (get_attr_length (insn) == 2)
    return \"jr%B1%#\\t%l0\";
  else if (get_attr_length (insn) == 4)
    /* return \"ext %l0@rm\; jr%B1%# %l0@rl\"; */
    return \"sjr%B1%#\\t%l0\";
  else
    /* return \"ext %l0@rh\; ext %l0@rm\; jr%B1%# %l0@rl\"; */
    return \"xjr%B1%#\\t%l0\";
}"
 [(set_attr "type" "branch")
  (set_attr "needs_delay_slot" "yes")])


;; Unconditional and other jump instructions.

(define_insn "jump"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  ""
  "*
{
  if (get_attr_length (insn) == 2)
    return \"jp%#\\t%l0\";
  else if (get_attr_length (insn) == 4)
    /* return \"ext %l0@rm\; jp%# %l0@rl\"; */
    return \"sjp%#\\t%l0\";
  else
    /* return \"ext %l0@rh\; ext %l0@rm\; jp%# %l0@rl\"; */
    return \"xjp%#\\t%l0\";
}"
  [(set_attr "type" "branch")
   (set_attr "needs_delay_slot" "yes")])


(define_insn "indirect_jump"
  [(set (pc) (match_operand:SI 0 "register_operand" "r"))]
  ""
  "jp%#\\t%0"
  [(set_attr "length" "2")
   (set_attr "needs_delay_slot" "yes")])


(define_insn "tablejump"
  [(set (pc) (match_operand:SI 0 "register_operand" "r"))
   (use (label_ref (match_operand 1 "" "")))]
  ""
  "jp%#\\t%0"
  [(set_attr "length" "2")
   (set_attr "needs_delay_slot" "yes")])


;; Call subroutine with no return value.

(define_expand "call"
  [(call (match_operand:QI 0 "general_operand" "")
	 (match_operand:SI 1 "general_operand" ""))]
  ""
  "
{
  /* CHG K.Watanabe V1.7 >>>>>>> */
/*  if (! call_address_operand (XEXP (operands[0], 0))) */
  if (! call_address_operand (XEXP (operands[0], 0),QImode))
  /* CHG K.Watanabe V1.7 <<<<<<< */ 
  
  XEXP (operands[0], 0) = force_reg (SImode, XEXP (operands[0], 0));
  if (TARGET_LONG_CALLS)
    emit_call_insn (gen_call_internal_long (XEXP (operands[0], 0), operands[1]));
  else
    emit_call_insn (gen_call_internal_short (XEXP (operands[0], 0), operands[1]));
  DONE;
}")


;; C33: Define the follwing lines in c33.c.
;; call_address_operand()
;; {
;;	return (GET_CODE(op) == SYMBOL_REF || GET_CODE(op) == REG);
;; }

(define_insn "call_internal_short"
  [(call (mem:QI (match_operand:SI 0 "call_address_operand" "S,r"))
	 (match_operand:SI 1 "general_operand" "g,g"))]
  "! TARGET_LONG_CALLS"
  "@
  scall%#\\t%0
  call%#\\t%0"
  [(set_attr "length" "4,2")
   (set_attr "needs_delay_slot" "yes")])

(define_insn "call_internal_long"
  [(call (mem:QI (match_operand:SI 0 "call_address_operand" "S,r"))
	 (match_operand:SI 1 "general_operand" "g,g"))]
  "TARGET_LONG_CALLS"
  "@
  xcall%#\\t%0
  call%#\\t%0"
  [(set_attr "length" "6,2")
   (set_attr "needs_delay_slot" "yes")])


;; Call subroutine, returning value in operand 0
;; (which must be a hard register).

(define_expand "call_value"
  [(set (match_operand 0 "" "")
	(call (match_operand:QI 1 "general_operand" "")
	      (match_operand:SI 2 "general_operand" "")))]
  ""
  "
{
  /* CHG K.Watanabe V1.7 >>>>>>> */ 
/*  if (! call_address_operand (XEXP (operands[1], 0))) */
  if (! call_address_operand (XEXP (operands[1], 0),QImode))
  /* CHG K.Watanabe V1.7 <<<<<<< */ 
  
    XEXP (operands[1], 0) = force_reg (SImode, XEXP (operands[1], 0));
  if (TARGET_LONG_CALLS)
    emit_call_insn (gen_call_value_internal_long (operands[0],
	 				          XEXP (operands[1], 0),
					          operands[2]));
  else
    emit_call_insn (gen_call_value_internal_short (operands[0],
	 				           XEXP (operands[1], 0),
					           operands[2]));
  DONE;
}")

(define_insn "call_value_internal_short"
  [(set (match_operand 0 "" "=r,r")
	(call (mem:QI (match_operand:SI 1 "call_address_operand" "S,r"))
	      (match_operand:SI 2 "general_operand" "g,g")))]
  "! TARGET_LONG_CALLS"
  "@
  scall%#\\t%1
  call%#\\t%1"
  [(set_attr "length" "4,2")
   (set_attr "needs_delay_slot" "yes")])

(define_insn "call_value_internal_long"
  [(set (match_operand 0 "" "=r,r")
	(call (mem:QI (match_operand:SI 1 "call_address_operand" "S,r"))
	      (match_operand:SI 2 "general_operand" "g,g")))]
  "TARGET_LONG_CALLS"
  "@
  xcall%#\\t%1
  call%#\\t%1"
  [(set_attr "length" "6,2")
   (set_attr "needs_delay_slot" "yes")])


(define_insn "nop"
  [(const_int 0)]
  ""
  "nop"
  [(set_attr "length" "2")
   (set_attr "in_delay_slot" "yes")])

;; ----------------------------------------------------------------------
;; EXTEND INSTRUCTIONS
;; ----------------------------------------------------------------------

(define_insn "zero_extendhisi2"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(zero_extend:SI
	 (match_operand:HI 1 "nonimmediate_operand" "r,m")))]
  ""
  "* return output_move_single (operands, TRUE);"
  [(set_attr "length" "2,6")
   (set_attr "type" "other,load")
   (set_attr "in_delay_slot" "yes,no")])


(define_insn "zero_extendqisi2"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(zero_extend:SI
	 (match_operand:QI 1 "nonimmediate_operand" "r,m")))]
  ""
  "* return output_move_single (operands, TRUE);"
  [(set_attr "length" "2,6")
   (set_attr "type" "other,load")
   (set_attr "in_delay_slot" "yes,no")])


;;- sign extension instructions
(define_insn "extendhisi2"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(sign_extend:SI
	 (match_operand:HI 1 "nonimmediate_operand" "r,m")))]
  ""
  "* return output_move_single (operands, FALSE);"
  [(set_attr "length" "2,6")
   (set_attr "type" "other,load")
   (set_attr "in_delay_slot" "yes,no")])


(define_insn "extendqisi2"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(sign_extend:SI
	 (match_operand:QI 1 "nonimmediate_operand" "r,m")))]
  ""
  "* return output_move_single (operands, FALSE);"
  [(set_attr "length" "2,6")
   (set_attr "type" "other,load")
   (set_attr "in_delay_slot" "yes,no")])


;; ----------------------------------------------------------------------
;; SHIFTS
;; ----------------------------------------------------------------------

(define_expand "rotlsi3"
  [(set (match_operand:SI 0 "register_operand" "")
        (rotate:SI (match_operand:SI 1 "register_operand" "")
                   (match_operand:QI 2 "nonmemory_operand" "")))]
  ""
  "if (expand_a_shift (SImode, ROTATE, operands)) DONE;else FAIL;")

(define_insn "rotlsi3_c33"
  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r,r")
	(rotate:SI (match_operand:SI 1 "register_operand" "0,0,0,0,0")
	           (match_operand:QI 2 "nonmemory_operand" "r,M,N,O,n")))
   (clobber (match_scratch:QI 3 "=&r,X,X,X,X"))]
  "!TARGET_C33ADV && !TARGET_C33PE"
  "* return emit_a_shift (ROTATE, operands);"
  [(set_attr "length" "16,2,4,4,2")
   (set_attr "in_delay_slot" "no,yes,no,no,yes")])

(define_insn "rotlsi3_c33adv"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(rotate:SI (match_operand:SI 1 "register_operand" "0,0")
	           (match_operand:QI 2 "nonmemory_operand" "r,n")))]
  "TARGET_C33ADV || TARGET_C33PE"
  "@
   rl %0,%2
   rl %0,%2"
  [(set_attr "length" "2,2")
   (set_attr "in_delay_slot" "yes,yes")])


(define_expand "rotrsi3"
  [(set (match_operand:SI 0 "register_operand" "")
        (rotatert:SI (match_operand:SI 1 "register_operand" "")
                     (match_operand:QI 2 "nonmemory_operand" "")))]
  ""
  "if (expand_a_shift (SImode, ROTATERT, operands)) DONE;else FAIL;")

(define_insn "rotrsi3_c33"
  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r,r")
	(rotatert:SI (match_operand:SI 1 "register_operand" "0,0,0,0,0")
	             (match_operand:QI 2 "nonmemory_operand" "r,M,N,O,n")))
   (clobber (match_scratch:QI 3 "=&r,X,X,X,X"))]
  "!TARGET_C33ADV && !TARGET_C33PE"
  "* return emit_a_shift (ROTATERT, operands);"
  [(set_attr "length" "16,2,4,4,2")
   (set_attr "in_delay_slot" "no,yes,no,no,yes")])

(define_insn "rotrsi3_c33adv"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(rotatert:SI (match_operand:SI 1 "register_operand" "0,0")
	             (match_operand:QI 2 "nonmemory_operand" "r,n")))]
  "TARGET_C33ADV || TARGET_C33PE"
  "@
   rr %0,%2
   rr %0,%2"
  [(set_attr "length" "2,2")
   (set_attr "in_delay_slot" "yes,yes")])


/* C33: Arithmetical shift to left.
        ( The instruction output actually is logical shift instruction "sll" ) */
(define_expand "ashlsi3"
  [(set (match_operand:SI 0 "register_operand" "")
        (ashift:SI (match_operand:SI 1 "register_operand" "")
                   (match_operand:QI 2 "nonmemory_operand" "")))]
  ""
  "if (expand_a_shift (SImode, ASHIFT, operands)) DONE;else FAIL;")

(define_insn "ashlsi3_c33"
  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r,r,r")
        (ashift:SI (match_operand:SI 1 "register_operand" "0,0,0,0,0,0")
                   (match_operand:QI 2 "nonmemory_operand" "r,M,N,O,P,n")))
   (clobber (match_scratch:QI 3 "=&r,X,X,X,X,X"))]
  "!TARGET_C33ADV && !TARGET_C33PE"
  "* return emit_a_shift (ASHIFT, operands);"
  [(set_attr "length" "16,2,4,6,8,4")
   (set_attr "in_delay_slot" "no,yes,no,no,no,no")])

(define_insn "ashlsi3_c33adv"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
        (ashift:SI (match_operand:SI 1 "register_operand" "0,0")
                   (match_operand:QI 2 "nonmemory_operand" "r,n")))]
  "TARGET_C33ADV || TARGET_C33PE"
  "@
   sll %0,%2
   sll %0,%2"
  [(set_attr "length" "2,2")
   (set_attr "in_delay_slot" "yes,yes")])


/* C33: Logical shift to right.
        ( The instruction output actually is logical shift instruction "srl" ) */
(define_expand "lshrsi3"
  [(set (match_operand:SI 0 "register_operand" "")
        (lshiftrt:SI (match_operand:SI 1 "register_operand" "")
                     (match_operand:QI 2 "nonmemory_operand" "")))]
  ""
  "if (expand_a_shift (SImode, LSHIFTRT, operands)) DONE;else FAIL;")

(define_insn "lshrsi3_c33"
  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r,r,r")
	(lshiftrt:SI (match_operand:SI 1 "register_operand" "0,0,0,0,0,0")
		     (match_operand:QI 2 "nonmemory_operand" "r,M,N,O,P,n")))
   (clobber (match_scratch:QI 3 "=&r,X,X,X,X,X"))]
  "!TARGET_C33ADV && !TARGET_C33PE"
  "* return emit_a_shift (LSHIFTRT, operands);"
  [(set_attr "length" "16,2,4,6,8,4")
   (set_attr "in_delay_slot" "no,yes,no,no,no,no")])

(define_insn "lshrsi3_c33adv"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(lshiftrt:SI (match_operand:SI 1 "register_operand" "0,0")
		     (match_operand:QI 2 "nonmemory_operand" "r,n")))]
  "TARGET_C33ADV || TARGET_C33PE"
  "@
   srl %0,%2
   srl %0,%2"
  [(set_attr "length" "2,2")
   (set_attr "in_delay_slot" "yes,yes")])


/* C33: Arithmetical shift to right.
        ( The instruction output actually is arithmetical shift instruction "sra" ) */
(define_expand "ashrsi3"
  [(set (match_operand:SI 0 "register_operand" "")
        (ashiftrt:SI (match_operand:SI 1 "register_operand" "")
                     (match_operand:QI 2 "nonmemory_operand" "")))]
  ""
  "if (expand_a_shift (SImode, ASHIFTRT, operands)) DONE;else FAIL;")

(define_insn "ashrsi3_c33"
  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r,r")
	(ashiftrt:SI (match_operand:SI 1 "register_operand" "0,0,0,0,0")
		     (match_operand:QI 2 "nonmemory_operand" "r,M,N,O,n")))
   (clobber (match_scratch:QI 3 "=&r,X,X,X,X"))]
  "!TARGET_C33ADV && !TARGET_C33PE"
  "* return emit_a_shift (ASHIFTRT, operands);"
  [(set_attr "length" "16,2,4,6,8")
   (set_attr "in_delay_slot" "no,yes,no,no,no")])

(define_insn "ashrsi3_c33adv"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(ashiftrt:SI (match_operand:SI 1 "register_operand" "0,0")
		     (match_operand:QI 2 "nonmemory_operand" "r,n")))]
  "TARGET_C33ADV || TARGET_C33PE"
  "@
   sra %0,%2
   sra %0,%2"
  [(set_attr "length" "2,2")
   (set_attr "in_delay_slot" "yes,yes")])



;; Block moves, see c33.c for more details.
;; Argument 0 is the destination
;; Argument 1 is the source
;; Argument 2 is the length
;; Argument 3 is the alignment

;; C33: Besed on mips.

(define_expand "movstrsi"
  [(parallel [(set (match_operand:BLK 0 "general_operand" "")
		   (match_operand:BLK 1 "general_operand" ""))
	      (use (match_operand:SI 2 "const_int_operand" ""))
	      (use (match_operand:SI 3 "const_int_operand" ""))])]
  ""
  "
{
  if (operands[0])		/* avoid unused code messages */
    {
      expand_block_move (operands);
      DONE;
    }
}")

;; Insn generated by block moves

;;; CHG K.Watanabe V1.7 >>>>>>>
;;;; C33: "register_operand" shall not be "r" but be "+r".
;;;;      Because the value of "destination/ source" is rewritten in "output_block_move()".

;;(define_insn "movstrsi_internal"
;;  [(set (mem:BLK (match_operand:SI 0 "register_operand" "r"))	;; destination
;;	(mem:BLK (match_operand:SI 1 "register_operand" "r")))	;; source
;;   (clobber (match_dup 0))					;; destination
;;   (clobber (match_dup 1))					;; source
;;   (clobber (match_scratch:SI 4 "=&r"))				;; temp 1
;;   (clobber (match_scratch:SI 5 "=&r"))				;; temp 2
;;   (clobber (match_scratch:SI 6 "=&r"))				;; temp 3
;;   (clobber (match_scratch:SI 7 "=&r"))				;; temp 4
;;   (use (match_operand:SI 2 "const_int_operand" ""))		;; # bytes to move
;;   (use (match_operand:SI 3 "const_int_operand" ""))		;; alignment
;;   (use (const_int 0))]						;; normal block move
;;  ""
;;  "* return output_block_move (insn, operands, 4);"
;;  [(set_attr "length"	"20")])

(define_insn "movstrsi_internal"
  [(set (mem:BLK (match_operand:SI 0 "register_operand" "+r"))	;; destination
	(mem:BLK (match_operand:SI 1 "register_operand" "+r")))	;; source
   (clobber (match_dup 0))					;; destination
   (clobber (match_dup 1))					;; source
   (clobber (match_scratch:SI 4 "=&r"))				;; temp 1
   (clobber (match_scratch:SI 5 "=&r"))				;; temp 2
   (clobber (match_scratch:SI 6 "=&r"))				;; temp 3
   (clobber (match_scratch:SI 7 "=&r"))				;; temp 4
   (use (match_operand:SI 2 "const_int_operand" ""))		;; # bytes to move
   (use (match_operand:SI 3 "const_int_operand" ""))		;; alignment
   (use (const_int 0))]						;; normal block move
  ""
  "* return output_block_move (insn, operands, 4);"
  [(set_attr "length"	"20")])
;;; CHG K.Watanabe V1.7 <<<<<<<
  
  
  
;; ide 2000.10.4 Added
;; C33: "peephole" for reducing ext by replacing "shift/and".
;;      watanabe 2001.12.28 
;;          The following definition is for ASHIFT( shift to left ).
;;          Another definiton is necessary for shift to right.

(define_peephole
  [(parallel [
	(set (match_operand:SI 0 "register_operand" "")
	(match_operator:SI 3 "nshift_operator" 
	 [(match_operand:SI 1 "register_operand" "0")
	 (match_operand:QI 2 "const_int_operand" "n")]))
   (clobber (scratch:QI))])
   (set (match_operand:SI 4 "register_operand" "r")
	(and:SI (match_operand:SI 5 "register_operand" "%0")
		(match_operand:SI 6 "nonmemory_operand" "n")))
]

   "
   /* C33: The registers for the process must be the same. */
   (REGNO(operands[0]) == REGNO(operands[4]))
	/* C33: Shift to left. */
	&& (GET_CODE(operands[3]) == ASHIFT)
	/* C33: The bit position before shifting is less than sign19 
	        and the bit position after shifting is sign19 or more.
	        Or the bit position before shifting is less than sign6 
	        and the bit position after shifting is sign6 or more.        */
	&& (
		(((unsigned) (INTVAL(operands[6]) >> INTVAL(operands[2])) + 0x40000 < 0x80000)
		&& ((unsigned) (INTVAL(operands[6])) + 0x40000 >= 0x80000))
	  ||(((unsigned) (INTVAL(operands[6]) >> INTVAL(operands[2])) + 0x20 < 0x40)
		&& ((unsigned) (INTVAL(operands[6])) + 0x20 >= 0x40))
	)
"
  "*
{
	int shift_cnt = INTVAL(operands[2]);
	int i = INTVAL(operands[6]);

	i >>= shift_cnt;
	operands[6] = GEN_INT(i);
        
	output_asm_insn(\"xand\\t%0,%6\\t;%v6\\t;peephole\",operands);

//	emit_a_shift (insn, operands);
	emit_a_shift (ASHIFT, operands);
	return \"\";
}")


